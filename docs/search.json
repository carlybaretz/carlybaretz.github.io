[
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Carly Baretz",
    "section": "",
    "text": "tidy: Tidy Tuesday Analysis\n\n\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nhistorical_spending &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-02-13/historical_spending.csv')\n\nRows: 13 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (10): Year, PercentCelebrating, PerPerson, Candy, Flowers, Jewelry, Gree...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ngifts_age &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-02-13/gifts_age.csv')\n\nRows: 6 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Age\ndbl (8): SpendingCelebrating, Candy, Flowers, Jewelry, GreetingCards, Evenin...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\ngifts_gender &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-02-13/gifts_gender.csv')\n\nRows: 2 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Gender\ndbl (8): SpendingCelebrating, Candy, Flowers, Jewelry, GreetingCards, Evenin...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nggplot(data=gifts_age, aes(x= Age, y = Flowers))+ \n  geom_point()+\n  ggtitle(\"Valentines Day Buying Habits and Age\")\n\n\n\n\n\n\n\n\n\nbabynames &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-03-22/babynames.csv')\n\nRows: 1924665 Columns: 5\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): sex, name\ndbl (3): year, n, prop\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nbabynames &lt;- babynames %&gt;% \n filter(n &gt; 80000)\n\nggplot(babynames, aes(x= \"\", y = prop, fill= name))+ \n  geom_col()+\n  coord_polar(theta=\"y\")+\n  ggtitle(\"2022 Baby Names for Names With More Than 80,000 Babies\")"
  },
  {
    "objectID": "babynames.html",
    "href": "babynames.html",
    "title": "Baby Names",
    "section": "",
    "text": "library(tidyverse)\nbabynames &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-03-22/babynames.csv')\n\nbabynames &lt;- babynames %&gt;% \n filter(n &gt; 80000)\n\nggplot(babynames, aes(x= \"\", y = prop, fill= name))+ \n  geom_col()+\n  coord_polar(theta=\"y\")+\n  ggtitle(\"2022 Baby Names for Names With More Than 80,000 Babies\")\n\n\n\n\n\n\n\n\nWhere I found the tidy Tuesday (https://github.com/rfordatascience/tidytuesday/tree/master/data)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Carly Baretz",
    "section": "",
    "text": "I’m Carly Baretz, a sophomore at Pitzer College from New York City studying Human Centered Design and Data Science!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "valentines.html",
    "href": "valentines.html",
    "title": "Valentines",
    "section": "",
    "text": "library(\"tidyverse\")\nhistorical_spending &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-02-13/historical_spending.csv')\ngifts_age &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-02-13/gifts_age.csv')\ngifts_gender &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2024/2024-02-13/gifts_gender.csv')\n\nggplot(data=gifts_age, aes(x= Age, y = Flowers))+ \n  geom_point()+\n  ggtitle(\"Valentines Day Buying Habits and Age\")\n\n\n\n\n\n\n\n\nWhere I found the tidy Tuesday (https://github.com/rfordatascience/tidytuesday/tree/master/data)"
  },
  {
    "objectID": "Project2.html",
    "href": "Project2.html",
    "title": "Project 2",
    "section": "",
    "text": "Data can be found from Tidy Tuesday: (https://github.com/rfordatascience/tidytuesday/tree/master/data)\n\nlibrary(tidyverse)\n\nnetflix_titles &lt;- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-04-20/netflix_titles.csv')\n\nnetflix_titles$genre_count &lt;- str_count(netflix_titles$listed_in, \",\") + 1\n\n\ngenres &lt;- netflix_titles |&gt;\n  separate_rows(listed_in, sep = \",\")|&gt;\n  group_by(listed_in) |&gt;\n  summarise(count = n()) |&gt;\n  arrange(desc(count))\n\n# Plot the top 10 genres by count\nggplot(genres[1:10,], aes(x = reorder(listed_in, -count), y = count)) +\n  geom_bar(stat = \"identity\", fill = \"blue\") +\n  labs(title = \"Top 10 Genres by Number of Titles\",\n       x = \"Genre\", y = \"Count\") +\n  theme_minimal() +\n  coord_flip()\n\n\n\n\n\n\n\n\nThe bar graph above shows the top 10 genres on Netflix by amount of titles. You can see that Netflix largest genre by which is has the most titles is international movies, with Netflix having upwards of 2,500 international movies.\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(stringr)\n\n\nnetflix_titles$title_word_count &lt;- str_count(netflix_titles$title, \"\\\\b\\\\w+\\\\b\")\nnetflix_titles$contains_common_word &lt;- str_detect(netflix_titles$title, \"\\\\b(Love|Story|Adventure)\\\\b\")\n\n\ntitle_word_distribution &lt;- netflix_titles |&gt;\n  group_by(title_word_count, contains_common_word) |&gt;\n  summarise(count = n()) |&gt;\n  arrange(desc(count))\n\n\nggplot(title_word_distribution, aes(x = factor(title_word_count), y = count, fill = contains_common_word)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  labs(title = \"Distribution of Netflix Titles by Word Count and Common Words (Love, Story, Adventure)\",\n       x = \"Number of Words in Title\", y = \"Count of Titles\",\n       fill = \"Contains 'Love', 'Story', or 'Adventure'\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\nThis graph shows the distribution of number of words in titles on Netflix, showing that most of the titles on Netflix are 2 words long. Additionally, the graph shows the prevalence of titles with 3 common words: love, story, and adventure. The graph shows that most of the titles do not contain “love,” “story,” or “adventure,” but it shows that if the words do appear, they show up in titles ranging from 1 word long to 13 words long.\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(stringr)\n\n\nnetflix_titles$year_added &lt;- str_extract(netflix_titles$date_added, \"\\\\d{4}\")\n\nnetflix_titles &lt;- netflix_titles |&gt;\n  filter(!is.na(year_added))\n\ntitles_by_year &lt;- netflix_titles |&gt;\n  group_by(year_added) |&gt;\n  summarise(count = n()) |&gt;\n  arrange(year_added)\n\nggplot(titles_by_year, aes(x = year_added, y = count)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\") +\n  labs(title = \"Number of Netflix Titles Added by Year\",\n       x = \"Year\", y = \"Number of Titles\") +\n  theme_minimal()"
  },
  {
    "objectID": "ds2-hw3-carlybaretz/ds2-hw3-wrangle.html",
    "href": "ds2-hw3-carlybaretz/ds2-hw3-wrangle.html",
    "title": "DS002R - HW 3 - Wrangling",
    "section": "",
    "text": "Back to the Midwest!\nIn this part you will revisit and build on some of your findings from HW 2, where you explored the midwest data frame. Remember that this data frame is bundled with the ggplot2 package and is automatically loaded when you load the tidyverse package. As a refresher, the data contains demographic characteristics of counties in the Midwest region of the United States. You can read documentation for the data set, including variable definitions by typing ?midwest in the Console or searching for midwest in the Help pane.\n\n\n\n\n\n\nNote\n\n\n\nThe data in the midwest data frame are from the 2000 census, so the information you compute below is likely slightly different from the values today.\n\n\n\n\nCalculate the number of counties in each state and display your results in descending order of number of counties. Which state has the highest number of counties, and how many? Which state has the lowest number, and how many?\n\n\n\nWithin a state, two counties can’t have the same name, but across states county names can be shared. A friend says “Look, there is a county called XYZ in EVERY state in this dataset!” In a single pipeline, discover all counties that could fill in the value of XYZ. Your output should be a data frame with two columns: county and the number of times they appear in the data.\n\n\n\n\n\n\nTip\n\n\n\nYou will want to use the filter() function in your answer, which requires a logical condition to describe what you want to filter for. For example filter(x &gt; 2) means filter for values of x greater than 2, filter(y &lt;= 3) means filter for values of y less than or equal to 3.\n\n\n\noperator\ndefinition\n\n\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal to\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal to\n\n\n==\nexactly equal to\n\n\n!=\nnot equal to\n\n\nx & y\nx AND y\n\n\nx | y\nx OR y\n\n\nis.na(x)\ntest if x is NA\n\n\n!is.na(x)\ntest if x is not NA\n\n\nx %in% y\ntest if x is in y\n\n\n!(x %in% y)\ntest if x is not in y\n\n\n!x\nnot x\n\n\n\nThe table above is a summary of logical operators and how to articulate them in R.\n\n\n\n\n\nConsider the following box plot of population densities where you were can see some counties have extreme values.\n\n\n\n\n\n\n\n\n\nIdentify the counties described in each part:\n\nThe counties with a population density higher than 25,000. Your code must use the filter() function.\nThe county with the highest population density. Your code must use the max() function.\n\n\n\n\n\n\n\nNote\n\n\n\nAnswer using a single data wrangling pipeline for each part. Your response should be a data frame with five columns: county name, state name, population density, total population, and area, in this order. If your response has multiple rows, the data frame should be arranged in descending order of population density.\n\n\n\n\n\nLet’s say that you want to describe the distribution of population densities. The following is one acceptable description (in words) that touches on shape, center, and spread of this distribution. Create a plot that fits the description, and calculate the values that should go into the blanks.\n\nThe distribution of population density of counties is unimodal and extremely right-skewed. A typical Midwestern county has population density of ____ people per unit area. The middle 50% of the counties have population densities between ___ to ___ people per unit area.\n\n\n\n\n\n\n\nTip\n\n\n\nThink about which measures of center and spread are appropriate for skewed distributions. That is, there is a right answer for the choice of functions you use to calculate the center and spread.\n\n\n\n\n\nRecall the visualization from HW 2 that showed the proportion of urban counties in each state.\n\nmidwest &lt;- midwest |&gt;\n  mutate(metro = if_else(inmetro == 1, \"Yes\", \"No\"))\n\nggplot(midwest, aes(x = state, fill = metro)) +\n  geom_bar(position = \"fill\") +\n  labs(\n    title = \"Do some states have more urban counties than others?\",\n    x = \"State\",\n    y = \"Proportion in metro area\",\n    fill = \"In metro area?\"\n  )\n\n\n\n\n\n\n\n\nIn a single data pipeline, calculate the proportion of residents in a metro area for each state.\n\n\n\nReturn to the following scatter plot of percentage below poverty vs. percentage of people with a college degree, where the color and shape of points are determined by state. Recall that you were asked to identify (by name) at least one county that is a clear outlier.\n\n\n\n\n\n\n\n\n\n\nIn a single pipeline, identify the observations marked in the orange square on the upper left corner. Your answer should be a data frame with four variables: county, state, percentage below poverty, and percentage college educated.\nIn a single pipeline, identify the observations marked in the red square in the plot above. Your answer should again be a data frame with four variables: county, state, percentage below poverty, and percentage college educated.\nBring your answers from part (a) and part (b) together! In a single pipeline, and a single filter() statement, identify the observations marked in the red and orange square in the plot above. Your answer should again be a data frame with four variables: county, state, percentage below poverty, and percentage college educated.\nCreate a new variable in midwest called potential_outlier. This variable should take on the value:\n\n\nYes if the point is one the ones you identified in part (c), i.e., one of the points marked in the squares in the plot above.\nNo otherwise.\n\nThen, display the updated midwest data frame, with county, state, percentage below poverty, percentage college educated, potential_outlier as the selected variables, arranged in ascending order of potential_outlier. (Hint: look above and/or recall how metro was calculated using the function if_else().)\n\nRecreate the visualization above, i.e. a scatterplot of percentage below poverty vs. percentage of people with a college degree, however color the points by the newly created potential_outlier variable instead of state.\n\n\n\n\n\nIn a single pipeline, calculate the total population for each state and save the resulting data frame as state_population and display it in descending order of total population.\nThen, in a separate pipeline, calculate the proportion of the total population in each state (e.g., find the percent of people living in WI out of all the people in the midwest) and, once again, display the results in descending order of proportion of population.\n\n\n\n\n\n\n\nTip\n\n\n\nIn answering parts (a) and (b), you’ll create two new variables, one for total population and other for proportion of total proportion. Make sure to give them “reasonable” names – short but evocative.\n\n\n\nWhich Midwestern state is most populous and what percent of the Midwest population lives there? Which is the least populous and what percent lives there?\n\n\n\n\nCalculate the average percentage below poverty for each state and save the resulting data frame as state_poverty with the columns state and mean_percbelowpoverty.\nThen, in a new pipeline, display the state_poverty data frame in ascending order of mean_percbelowpoverty. Which state has the lowest average percentage below poverty across its counties? Which state has the highest average percentage below poverty across its counties?"
  },
  {
    "objectID": "ds2-hw3-carlybaretz/ds2-hw3-wrangle.html#part-1",
    "href": "ds2-hw3-carlybaretz/ds2-hw3-wrangle.html#part-1",
    "title": "DS002R - HW 3 - Wrangling",
    "section": "",
    "text": "Back to the Midwest!\nIn this part you will revisit and build on some of your findings from HW 2, where you explored the midwest data frame. Remember that this data frame is bundled with the ggplot2 package and is automatically loaded when you load the tidyverse package. As a refresher, the data contains demographic characteristics of counties in the Midwest region of the United States. You can read documentation for the data set, including variable definitions by typing ?midwest in the Console or searching for midwest in the Help pane.\n\n\n\n\n\n\nNote\n\n\n\nThe data in the midwest data frame are from the 2000 census, so the information you compute below is likely slightly different from the values today.\n\n\n\n\nCalculate the number of counties in each state and display your results in descending order of number of counties. Which state has the highest number of counties, and how many? Which state has the lowest number, and how many?\n\n\n\nWithin a state, two counties can’t have the same name, but across states county names can be shared. A friend says “Look, there is a county called XYZ in EVERY state in this dataset!” In a single pipeline, discover all counties that could fill in the value of XYZ. Your output should be a data frame with two columns: county and the number of times they appear in the data.\n\n\n\n\n\n\nTip\n\n\n\nYou will want to use the filter() function in your answer, which requires a logical condition to describe what you want to filter for. For example filter(x &gt; 2) means filter for values of x greater than 2, filter(y &lt;= 3) means filter for values of y less than or equal to 3.\n\n\n\noperator\ndefinition\n\n\n\n\n&lt;\nless than\n\n\n&lt;=\nless than or equal to\n\n\n&gt;\ngreater than\n\n\n&gt;=\ngreater than or equal to\n\n\n==\nexactly equal to\n\n\n!=\nnot equal to\n\n\nx & y\nx AND y\n\n\nx | y\nx OR y\n\n\nis.na(x)\ntest if x is NA\n\n\n!is.na(x)\ntest if x is not NA\n\n\nx %in% y\ntest if x is in y\n\n\n!(x %in% y)\ntest if x is not in y\n\n\n!x\nnot x\n\n\n\nThe table above is a summary of logical operators and how to articulate them in R.\n\n\n\n\n\nConsider the following box plot of population densities where you were can see some counties have extreme values.\n\n\n\n\n\n\n\n\n\nIdentify the counties described in each part:\n\nThe counties with a population density higher than 25,000. Your code must use the filter() function.\nThe county with the highest population density. Your code must use the max() function.\n\n\n\n\n\n\n\nNote\n\n\n\nAnswer using a single data wrangling pipeline for each part. Your response should be a data frame with five columns: county name, state name, population density, total population, and area, in this order. If your response has multiple rows, the data frame should be arranged in descending order of population density.\n\n\n\n\n\nLet’s say that you want to describe the distribution of population densities. The following is one acceptable description (in words) that touches on shape, center, and spread of this distribution. Create a plot that fits the description, and calculate the values that should go into the blanks.\n\nThe distribution of population density of counties is unimodal and extremely right-skewed. A typical Midwestern county has population density of ____ people per unit area. The middle 50% of the counties have population densities between ___ to ___ people per unit area.\n\n\n\n\n\n\n\nTip\n\n\n\nThink about which measures of center and spread are appropriate for skewed distributions. That is, there is a right answer for the choice of functions you use to calculate the center and spread.\n\n\n\n\n\nRecall the visualization from HW 2 that showed the proportion of urban counties in each state.\n\nmidwest &lt;- midwest |&gt;\n  mutate(metro = if_else(inmetro == 1, \"Yes\", \"No\"))\n\nggplot(midwest, aes(x = state, fill = metro)) +\n  geom_bar(position = \"fill\") +\n  labs(\n    title = \"Do some states have more urban counties than others?\",\n    x = \"State\",\n    y = \"Proportion in metro area\",\n    fill = \"In metro area?\"\n  )\n\n\n\n\n\n\n\n\nIn a single data pipeline, calculate the proportion of residents in a metro area for each state.\n\n\n\nReturn to the following scatter plot of percentage below poverty vs. percentage of people with a college degree, where the color and shape of points are determined by state. Recall that you were asked to identify (by name) at least one county that is a clear outlier.\n\n\n\n\n\n\n\n\n\n\nIn a single pipeline, identify the observations marked in the orange square on the upper left corner. Your answer should be a data frame with four variables: county, state, percentage below poverty, and percentage college educated.\nIn a single pipeline, identify the observations marked in the red square in the plot above. Your answer should again be a data frame with four variables: county, state, percentage below poverty, and percentage college educated.\nBring your answers from part (a) and part (b) together! In a single pipeline, and a single filter() statement, identify the observations marked in the red and orange square in the plot above. Your answer should again be a data frame with four variables: county, state, percentage below poverty, and percentage college educated.\nCreate a new variable in midwest called potential_outlier. This variable should take on the value:\n\n\nYes if the point is one the ones you identified in part (c), i.e., one of the points marked in the squares in the plot above.\nNo otherwise.\n\nThen, display the updated midwest data frame, with county, state, percentage below poverty, percentage college educated, potential_outlier as the selected variables, arranged in ascending order of potential_outlier. (Hint: look above and/or recall how metro was calculated using the function if_else().)\n\nRecreate the visualization above, i.e. a scatterplot of percentage below poverty vs. percentage of people with a college degree, however color the points by the newly created potential_outlier variable instead of state.\n\n\n\n\n\nIn a single pipeline, calculate the total population for each state and save the resulting data frame as state_population and display it in descending order of total population.\nThen, in a separate pipeline, calculate the proportion of the total population in each state (e.g., find the percent of people living in WI out of all the people in the midwest) and, once again, display the results in descending order of proportion of population.\n\n\n\n\n\n\n\nTip\n\n\n\nIn answering parts (a) and (b), you’ll create two new variables, one for total population and other for proportion of total proportion. Make sure to give them “reasonable” names – short but evocative.\n\n\n\nWhich Midwestern state is most populous and what percent of the Midwest population lives there? Which is the least populous and what percent lives there?\n\n\n\n\nCalculate the average percentage below poverty for each state and save the resulting data frame as state_poverty with the columns state and mean_percbelowpoverty.\nThen, in a new pipeline, display the state_poverty data frame in ascending order of mean_percbelowpoverty. Which state has the lowest average percentage below poverty across its counties? Which state has the highest average percentage below poverty across its counties?"
  },
  {
    "objectID": "ds2-hw3-carlybaretz/ds2-hw3-wrangle.html#part-2",
    "href": "ds2-hw3-carlybaretz/ds2-hw3-wrangle.html#part-2",
    "title": "DS002R - HW 3 - Wrangling",
    "section": "Part 2",
    "text": "Part 2\nPoor nameless kitties in Seattle\nUse the seattlepets dataset from the openintro R package to do some wrangling:\n\nQuestion 9\n\nHow many pets are included in the dataset? (Print the answer to the screen, show the R code which is your work, and write a complete sentence with the answer.)\nHow many variables are there for each pet? What are the names of the variables? Again, show your work using R code (not the Viewer or the Environment) and write a complete sentence.\nWhat are the three most common pet names in Seattle? (You’ll need to use the function n() which counts the number of rows.)\n\n\n\nQuestion 10\n\nWhat are the three most common names for each of the cat and dog species? Your initial code may only tell you about dogs (and the poor unnamed kitties). The slice_ family of functions pulls out a specified number of rows. For example, slice_min() pulls out the smallest rows, slice_max() pulls out the largest rows, slice_head() pulls out the first row, … (see the cheatsheets! https://www.rstudio.com/resources/cheatsheets/).\nI’ve added a new column to the dataset which gives the proportion of a particular species with the given name. Create a scatterplot of the 20 most popular pet names (as measured by the max proportion of the species with that name - the value calculated below). The x-axis will represent the proportion of cats with that name, the y-axis will represent the proportion of dogs with that name.\n\n\nseattlepets_w_prop &lt;- seattlepets |&gt;\n  group_by(species, animal_name) |&gt;\n  summarize(n_names = n()) |&gt;\n  mutate(prop_names = n_names / sum(n_names)) |&gt;\n  ungroup()\n\nhead(seattlepets_w_prop)\n\n# A tibble: 6 × 4\n  species animal_name     n_names prop_names\n  &lt;chr&gt;   &lt;chr&gt;             &lt;int&gt;      &lt;dbl&gt;\n1 Cat     \"\\\"Mama\\\" Maya\"       1  0.0000578\n2 Cat     \"\\\"Mo\\\"\"              1  0.0000578\n3 Cat     \"'Alani\"              1  0.0000578\n4 Cat     \"-\"                   1  0.0000578\n5 Cat     \"1\"                   1  0.0000578\n6 Cat     \"2\"                   1  0.0000578\n\n\nHint 1: you’ll need to pivot_ (wider or longer?)\nHint 2: after pivoting, you’ll need to sort based on the proportion. But you have two columns of proportions! Sort on the maximum of the two columns. In order to do a piece-wise maximum (element by element) in your mutate() call, use the function pmax(first column, second column, na.rm = TRUE).\nHint3: after you get the basic scatterplot made, clean it up in the following ways:\n\nadd pet name labels using geom_text() [Or better, use geom_text_repel() in ggrepel]\nadd the line y = x using geom_abline()\nmake the x-axis label something better\nremove the y-axis label and use the title to provide the y-axis (so that the letters are written horizontally instead of vertically)\nremove the poor kitties that don’t have a name"
  }
]